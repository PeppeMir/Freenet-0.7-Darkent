<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="it">
<head>
<!-- Generated by javadoc (version 1.7.0_51) on Mon Mar 09 10:58:30 CET 2015 -->
<title>MessagesExchangerProtocol</title>
<meta name="date" content="2015-03-09">
<link rel="stylesheet" type="text/css" href="../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="MessagesExchangerProtocol";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/MessagesExchangerProtocol.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../deprecated-list.html">Deprecated</a></li>
<li><a href="../index-files/index-1.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../protocol/LinkableProtocol.html" title="class in protocol"><span class="strong">Prev Class</span></a></li>
<li>Next Class</li>
</ul>
<ul class="navList">
<li><a href="../index.html?protocol/MessagesExchangerProtocol.html" target="_top">Frames</a></li>
<li><a href="MessagesExchangerProtocol.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">protocol</div>
<h2 title="Class MessagesExchangerProtocol" class="title">Class MessagesExchangerProtocol</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>protocol.MessagesExchangerProtocol</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd>java.lang.Cloneable, peersim.cdsim.CDProtocol, peersim.core.Protocol, peersim.edsim.EDProtocol</dd>
</dl>
<hr>
<br>
<pre>public class <span class="strong">MessagesExchangerProtocol</span>
extends java.lang.Object
implements peersim.edsim.EDProtocol, peersim.cdsim.CDProtocol</pre>
<div class="block">Class that implements the Hybrid Cycle-Driven & Event-Driven protocol and so manages the FPeer's periodic requests and 
  messages exchanging with the others FPeers of the overlay network.</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>March 9, 2015</dd>
<dt><span class="strong">Author:</span></dt>
  <dd>Giuseppe Miraglia</dd></dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>private double</code></td>
<td class="colLast"><code><strong><a href="../protocol/MessagesExchangerProtocol.html#biasFactor">biasFactor</a></strong></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>private int</code></td>
<td class="colLast"><code><strong><a href="../protocol/MessagesExchangerProtocol.html#cleanupFrequency">cleanupFrequency</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>private int</code></td>
<td class="colLast"><code><strong><a href="../protocol/MessagesExchangerProtocol.html#itselfPID">itselfPID</a></strong></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>private int</code></td>
<td class="colLast"><code><strong><a href="../protocol/MessagesExchangerProtocol.html#linkablePID">linkablePID</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>private int</code></td>
<td class="colLast"><code><strong><a href="../protocol/MessagesExchangerProtocol.html#maxHTL">maxHTL</a></strong></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>private int</code></td>
<td class="colLast"><code><strong><a href="../protocol/MessagesExchangerProtocol.html#maxHTLswap">maxHTLswap</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>private boolean</code></td>
<td class="colLast"><code><strong><a href="../protocol/MessagesExchangerProtocol.html#printsAllowed">printsAllowed</a></strong></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>private int</code></td>
<td class="colLast"><code><strong><a href="../protocol/MessagesExchangerProtocol.html#replicationFactor">replicationFactor</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>private static boolean</code></td>
<td class="colLast"><code><strong><a href="../protocol/MessagesExchangerProtocol.html#simStatToWrite">simStatToWrite</a></strong></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>private java.util.HashMap&lt;java.lang.Long,<a href="../structure/HashMapEntry.html" title="class in structure">HashMapEntry</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../protocol/MessagesExchangerProtocol.html#SRmessages">SRmessages</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>private static long</code></td>
<td class="colLast"><code><strong><a href="../protocol/MessagesExchangerProtocol.html#statisticsFileExtension">statisticsFileExtension</a></strong></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>private int</code></td>
<td class="colLast"><code><strong><a href="../protocol/MessagesExchangerProtocol.html#swapFrequency">swapFrequency</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>private int</code></td>
<td class="colLast"><code><strong><a href="../protocol/MessagesExchangerProtocol.html#transportPID">transportPID</a></strong></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>private long</code></td>
<td class="colLast"><code><strong><a href="../protocol/MessagesExchangerProtocol.html#uselessFactor">uselessFactor</a></strong></code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../protocol/MessagesExchangerProtocol.html#MessagesExchangerProtocol(java.lang.String)">MessagesExchangerProtocol</a></strong>(java.lang.String&nbsp;prefix)</code>
<div class="block">Constructor method.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>private void</code></td>
<td class="colLast"><code><strong><a href="../protocol/MessagesExchangerProtocol.html#changeAndSendMessage(structure.Message, structure.Message.Type, structure.FPeer, structure.FPeer)">changeAndSendMessage</a></strong>(<a href="../structure/Message.html" title="class in structure">Message</a>&nbsp;mex,
                    <a href="../structure/Message.Type.html" title="enum in structure">Message.Type</a>&nbsp;mexType,
                    <a href="../structure/FPeer.html" title="class in structure">FPeer</a>&nbsp;fpeer_sender,
                    <a href="../structure/FPeer.html" title="class in structure">FPeer</a>&nbsp;fpeer_receiver)</code>
<div class="block">Utility method performing the following operations: <br>
 1) changes the type of the passed message <code>mex</code> exploiting the passed <code>mexType</code>; <br>
 2) changes the last-hop FPeer of the passed message <code>mex</code> exploiting the passed FPeer <code>fpeer_sender</code>; <br>
 3) sends the passed message <code>mex</code> from the passed FPeer <code>fpeer_sender</code> to the passed FPeer 
    <code>fpeer_receiver</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>private void</code></td>
<td class="colLast"><code><strong><a href="../protocol/MessagesExchangerProtocol.html#cleanHashMap()">cleanHashMap</a></strong>()</code>
<div class="block">Cleanup routine for deallocation of useless entries in the protocol's HashMap.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.lang.Object</code></td>
<td class="colLast"><code><strong><a href="../protocol/MessagesExchangerProtocol.html#clone()">clone</a></strong>()</code>
<div class="block">Creates an identical (clone) Hybrid protocol.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>private int</code></td>
<td class="colLast"><code><strong><a href="../protocol/MessagesExchangerProtocol.html#findBestIndex(java.util.ArrayList, structure.HashMapEntry, structure.FPeer)">findBestIndex</a></strong>(java.util.ArrayList&lt;<a href="../structure/FPeer.html" title="class in structure">FPeer</a>&gt;&nbsp;neighborsList,
             <a href="../structure/HashMapEntry.html" title="class in structure">HashMapEntry</a>&nbsp;entry,
             <a href="../structure/FPeer.html" title="class in structure">FPeer</a>&nbsp;toAvoid)</code>
<div class="block">Tries to find a candidate FPeer, scanning <code>neighborsList</code> from the beginning, that satisfies the following
 two tests: <br><br>
 
 test 1) it is not already present in the <code>sentTo</code> field of the passed HashMap <code>entry</code>; <br>
 test 2) it is different from the passed FPeer <code>toAvoid</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>private void</code></td>
<td class="colLast"><code><strong><a href="../protocol/MessagesExchangerProtocol.html#handleBackwardMessage(structure.FPeer, structure.Message)">handleBackwardMessage</a></strong>(<a href="../structure/FPeer.html" title="class in structure">FPeer</a>&nbsp;fpeer,
                     <a href="../structure/Message.html" title="class in structure">Message</a>&nbsp;mex)</code>
<div class="block">Handles the <code>fpeer</code>'s receiving of the backward message <code>mex</code> (e.g.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>private void</code></td>
<td class="colLast"><code><strong><a href="../protocol/MessagesExchangerProtocol.html#handleMessageForwarding(structure.Message, structure.HashMapEntry, structure.FPeer, structure.FPeer, structure.FPeer)">handleMessageForwarding</a></strong>(<a href="../structure/Message.html" title="class in structure">Message</a>&nbsp;m,
                       <a href="../structure/HashMapEntry.html" title="class in structure">HashMapEntry</a>&nbsp;mEntry,
                       <a href="../structure/FPeer.html" title="class in structure">FPeer</a>&nbsp;fpeer_sender,
                       <a href="../structure/FPeer.html" title="class in structure">FPeer</a>&nbsp;fpeer_receveiver,
                       <a href="../structure/FPeer.html" title="class in structure">FPeer</a>&nbsp;fpeer_recFrom)</code>
<div class="block">Utility method that handles the forwarding of the passed message <code>m</code>, performing the following operations: <br>
 
 1) decreases the <code>m</code>'s HTL field value; <br>
 2) changes the <code>m</code>'s last hop FPeer field with the passed <code>fpeer_sender</code>; <br>
 3) forwards the message <code>m</code> from <code>fpeer_sender</code> to the FPeer <code>fpeer_receiver</code>; <br>
 4) adds "received from <code>fpeer_recFrom</code>" and "sent to <code>fpeer_receiver</code>" informations into the 
          running FPeer's HashMap.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>private void</code></td>
<td class="colLast"><code><strong><a href="../protocol/MessagesExchangerProtocol.html#handleReceivedGET(structure.FPeer, structure.Message)">handleReceivedGET</a></strong>(<a href="../structure/FPeer.html" title="class in structure">FPeer</a>&nbsp;fpeer,
                 <a href="../structure/Message.html" title="class in structure">Message</a>&nbsp;mex)</code>
<div class="block">Handles the <code>fpeer</code>'s receiving of the GET/GET_NOTFOUND message <code>mex</code>, performing the following operations: <br><br>
 
 First of all, it checks if its location key is the closest, w.r.t. the content location key, than all the location
 keys encountered up to now during the <code>mex</code>'s routing.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>private void</code></td>
<td class="colLast"><code><strong><a href="../protocol/MessagesExchangerProtocol.html#handleReceivedPUT_REPLICATION(structure.FPeer, structure.Message)">handleReceivedPUT_REPLICATION</a></strong>(<a href="../structure/FPeer.html" title="class in structure">FPeer</a>&nbsp;fpeer,
                             <a href="../structure/Message.html" title="class in structure">Message</a>&nbsp;mex)</code>
<div class="block">Handles the <code>fpeer</code>'s receiving of the PUT_REPLICATION/PUT_REPL_COLLISION message <code>mex</code>, performing the 
 following operations: <br><br>
 
 First of all, it checks if its location key is the closest, w.r.t. the content location key, than all the location
 keys encountered up to now during the <code>mex</code>'s routing.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>private void</code></td>
<td class="colLast"><code><strong><a href="../protocol/MessagesExchangerProtocol.html#handleReceivedPUT(structure.FPeer, structure.Message)">handleReceivedPUT</a></strong>(<a href="../structure/FPeer.html" title="class in structure">FPeer</a>&nbsp;fpeer,
                 <a href="../structure/Message.html" title="class in structure">Message</a>&nbsp;mex)</code>
<div class="block">Handles the <code>fpeer</code>'s receiving of the PUT message <code>mex</code>, performing the following operations: <br><br>
 
 - if <code>fpeer</code> contains the content location key in its own storage, it send backward a PUT_COLLISION message to the 
   neighbor from which it has received the PUT message <code>mex</code>; <br>
 
 - otherwise, <code>fpeer</code> try to select a neighbor that is closest w.r.t. the content location key to PUT than its
   location key: <br><br>
   
        => if this neighbor exists, <code>fpeer</code> forward the PUT request toward it; <br>
        => if this neighbor does not exists, <code>fpeer</code> stores the content location key in its own storage and forwards
           a PUT_REPLICATION message toward the <code>replicationFactor</code> closest w.r.t. the content location key neighbors, 
           having maximum HTL value and its reference as last hop FPeer.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>private void</code></td>
<td class="colLast"><code><strong><a href="../protocol/MessagesExchangerProtocol.html#handleReceivedSWAP(structure.FPeer, structure.Message)">handleReceivedSWAP</a></strong>(<a href="../structure/FPeer.html" title="class in structure">FPeer</a>&nbsp;fpeer,
                  <a href="../structure/Message.html" title="class in structure">Message</a>&nbsp;mex)</code>
<div class="block">Handles the <code>fpeer</code>'s receiving of the SWAP message <code>mex</code> performing the following operations: <br><br>
 
 First of all, it checks the HTL value of the message: if HTL > 0, then it select a random neighbor (different from 
 this from which it has received the actual request) toward which forward the SWAP request.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>private void</code></td>
<td class="colLast"><code><strong><a href="../protocol/MessagesExchangerProtocol.html#handleReceivedSWAPanswer(structure.FPeer, structure.Message)">handleReceivedSWAPanswer</a></strong>(<a href="../structure/FPeer.html" title="class in structure">FPeer</a>&nbsp;fpeer,
                        <a href="../structure/Message.html" title="class in structure">Message</a>&nbsp;mex)</code>
<div class="block">Handles the <code>fpeer</code>'s receiving of the answer <code>mex</code> relative to the SWAP message (e.g.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>private boolean</code></td>
<td class="colLast"><code><strong><a href="../protocol/MessagesExchangerProtocol.html#isLessWrtContent(double, double, double)">isLessWrtContent</a></strong>(double&nbsp;locKey1,
                double&nbsp;locKey2,
                double&nbsp;contentLocKey)</code>
<div class="block">Verifies if the passed location key <code>locKey1</code> is closest, in term of circular distance, than the other 
 passed location key <code>locKey2</code> w.r.t. the passed <code>contentLocKey</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../protocol/MessagesExchangerProtocol.html#nextCycle(peersim.core.Node, int)">nextCycle</a></strong>(peersim.core.Node&nbsp;peer,
         int&nbsp;pid)</code>
<div class="block">Implements the running FPeer's performing of some requests, based on probability and periods criteria.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../protocol/MessagesExchangerProtocol.html#performRequest(structure.Message.Type, structure.FPeer, double)">performRequest</a></strong>(<a href="../structure/Message.Type.html" title="enum in structure">Message.Type</a>&nbsp;mexType,
              <a href="../structure/FPeer.html" title="class in structure">FPeer</a>&nbsp;fpeer_sender,
              double&nbsp;contentLocKey)</code>
<div class="block">Implements the GET, PUT and SWAP requests operations, based on the passed parameter <code>mexType</code>: <br><br>
  
  - for <code>mexType</code> = PUT, <code>fpeer_sender</code> injects the passed content location key <code>contentLocKey</code> into the overlay network, 
    sending a PUT message request.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../protocol/MessagesExchangerProtocol.html#processEvent(peersim.core.Node, int, java.lang.Object)">processEvent</a></strong>(peersim.core.Node&nbsp;peer,
            int&nbsp;pid,
            java.lang.Object&nbsp;message)</code>
<div class="block">Handles the receiving of a message <code>message</code> from an FPeer <code>peer</code>, using the protocol having <code>pid</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>private void</code></td>
<td class="colLast"><code><strong><a href="../protocol/MessagesExchangerProtocol.html#replicatesTowardNeighbors(structure.FPeer, double)">replicatesTowardNeighbors</a></strong>(<a href="../structure/FPeer.html" title="class in structure">FPeer</a>&nbsp;fpeer,
                         double&nbsp;contentLocKey)</code>
<div class="block">Replicates the passed content location key <code>contentLocKey</code> sending at most <code>replicationFactor</code> PUT_REPLICATION
 messages from the running FPeer <code>fpeer</code> toward its top-neighbors, having all the same message identifier and
 the HTL value set to the <code>maxHTLvalue</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>private <a href="../structure/FPeer.html" title="class in structure">FPeer</a></code></td>
<td class="colLast"><code><strong><a href="../protocol/MessagesExchangerProtocol.html#selectNeighborForSwap(structure.FPeer, protocol.LinkableProtocol)">selectNeighborForSwap</a></strong>(<a href="../structure/FPeer.html" title="class in structure">FPeer</a>&nbsp;fpeer_proposer,
                     <a href="../protocol/LinkableProtocol.html" title="class in protocol">LinkableProtocol</a>&nbsp;lp)</code>
<div class="block">Tries to select a neighbor of the passed FPeer <code>fpeer_proposer</code> to involves into a SWAP process with itself.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>private void</code></td>
<td class="colLast"><code><strong><a href="../protocol/MessagesExchangerProtocol.html#sendMessage(peersim.core.Node, peersim.core.Node, structure.Message)">sendMessage</a></strong>(peersim.core.Node&nbsp;sender,
           peersim.core.Node&nbsp;receiver,
           <a href="../structure/Message.html" title="class in structure">Message</a>&nbsp;msg)</code>
<div class="block">Sends the message <code>msg</code> from the FPeer <code>sender</code> to Hybrid protocol of the FPeer <code>receiver</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>private void</code></td>
<td class="colLast"><code><strong><a href="../protocol/MessagesExchangerProtocol.html#storeContentAndInfo(structure.Message, structure.FPeer, structure.HashMapEntry)">storeContentAndInfo</a></strong>(<a href="../structure/Message.html" title="class in structure">Message</a>&nbsp;m,
                   <a href="../structure/FPeer.html" title="class in structure">FPeer</a>&nbsp;fpeer,
                   <a href="../structure/HashMapEntry.html" title="class in structure">HashMapEntry</a>&nbsp;mEntry)</code>
<div class="block">Stores the content location key of the passed message <code>m</code> into the local storage of the running FPeer <code>fpeer</code>,
 avoiding the store if the content location key is already present in the storage.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>private void</code></td>
<td class="colLast"><code><strong><a href="../protocol/MessagesExchangerProtocol.html#writeStatisticsOnFile(structure.Message)">writeStatisticsOnFile</a></strong>(<a href="../structure/Message.html" title="class in structure">Message</a>&nbsp;mex)</code>
<div class="block">Writes statistics of the passed message <code>mex</code> on the statistics file of the simulation.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="statisticsFileExtension">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>statisticsFileExtension</h4>
<pre>private static&nbsp;long statisticsFileExtension</pre>
</li>
</ul>
<a name="simStatToWrite">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>simStatToWrite</h4>
<pre>private static&nbsp;boolean simStatToWrite</pre>
</li>
</ul>
<a name="itselfPID">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>itselfPID</h4>
<pre>private&nbsp;int itselfPID</pre>
</li>
</ul>
<a name="transportPID">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>transportPID</h4>
<pre>private&nbsp;int transportPID</pre>
</li>
</ul>
<a name="linkablePID">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>linkablePID</h4>
<pre>private&nbsp;int linkablePID</pre>
</li>
</ul>
<a name="maxHTL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>maxHTL</h4>
<pre>private&nbsp;int maxHTL</pre>
</li>
</ul>
<a name="maxHTLswap">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>maxHTLswap</h4>
<pre>private&nbsp;int maxHTLswap</pre>
</li>
</ul>
<a name="replicationFactor">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>replicationFactor</h4>
<pre>private&nbsp;int replicationFactor</pre>
</li>
</ul>
<a name="uselessFactor">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>uselessFactor</h4>
<pre>private&nbsp;long uselessFactor</pre>
</li>
</ul>
<a name="cleanupFrequency">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cleanupFrequency</h4>
<pre>private&nbsp;int cleanupFrequency</pre>
</li>
</ul>
<a name="swapFrequency">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>swapFrequency</h4>
<pre>private&nbsp;int swapFrequency</pre>
</li>
</ul>
<a name="biasFactor">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>biasFactor</h4>
<pre>private&nbsp;double biasFactor</pre>
</li>
</ul>
<a name="printsAllowed">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>printsAllowed</h4>
<pre>private&nbsp;boolean printsAllowed</pre>
</li>
</ul>
<a name="SRmessages">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>SRmessages</h4>
<pre>private&nbsp;java.util.HashMap&lt;java.lang.Long,<a href="../structure/HashMapEntry.html" title="class in structure">HashMapEntry</a>&gt; SRmessages</pre>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="MessagesExchangerProtocol(java.lang.String)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>MessagesExchangerProtocol</h4>
<pre>public&nbsp;MessagesExchangerProtocol(java.lang.String&nbsp;prefix)</pre>
<div class="block">Constructor method. Sets up internal fields from the PeerSim configuration file, using <code>prefix</code>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>prefix</code> - the prefix, in the configuration file, representing the class.</dd></dl>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="clone()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clone</h4>
<pre>public&nbsp;java.lang.Object&nbsp;clone()</pre>
<div class="block">Creates an identical (clone) Hybrid protocol.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code>clone</code>&nbsp;in interface&nbsp;<code>peersim.core.Protocol</code></dd>
<dt><strong>Overrides:</strong></dt>
<dd><code>clone</code>&nbsp;in class&nbsp;<code>java.lang.Object</code></dd>
<dt><span class="strong">Returns:</span></dt><dd>cloned_prot the cloned Hybrid protocol.</dd></dl>
</li>
</ul>
<a name="cleanHashMap()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cleanHashMap</h4>
<pre>private&nbsp;void&nbsp;cleanHashMap()</pre>
<div class="block">Cleanup routine for deallocation of useless entries in the protocol's HashMap. 
 All the HashMap's entries that are not used for more than <code>inactivityToUseless</code> minutes are removed from the
 HashMap, saving memory.</div>
</li>
</ul>
<a name="writeStatisticsOnFile(structure.Message)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>writeStatisticsOnFile</h4>
<pre>private&nbsp;void&nbsp;writeStatisticsOnFile(<a href="../structure/Message.html" title="class in structure">Message</a>&nbsp;mex)</pre>
<div class="block">Writes statistics of the passed message <code>mex</code> on the statistics file of the simulation.
 Statistics consists in the pairs (messageType, messageTHC).</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>mex</code> - the message on which writes statistics</dd></dl>
</li>
</ul>
<a name="isLessWrtContent(double, double, double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isLessWrtContent</h4>
<pre>private&nbsp;boolean&nbsp;isLessWrtContent(double&nbsp;locKey1,
                       double&nbsp;locKey2,
                       double&nbsp;contentLocKey)</pre>
<div class="block">Verifies if the passed location key <code>locKey1</code> is closest, in term of circular distance, than the other 
 passed location key <code>locKey2</code> w.r.t. the passed <code>contentLocKey</code>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>locKey1</code> - the first location key to compare</dd><dd><code>locKey2</code> - the second location key to compare</dd><dd><code>contentLocKey</code> - the content location key</dd>
<dt><span class="strong">Returns:</span></dt><dd><code>true</code> if the passed <code>locKey1</code> is closest w.r.t. <code>contentLocKey</code> 
                   than <code>locKey2</code>. <code>false</code> otherwise.</dd></dl>
</li>
</ul>
<a name="findBestIndex(java.util.ArrayList, structure.HashMapEntry, structure.FPeer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findBestIndex</h4>
<pre>private&nbsp;int&nbsp;findBestIndex(java.util.ArrayList&lt;<a href="../structure/FPeer.html" title="class in structure">FPeer</a>&gt;&nbsp;neighborsList,
                <a href="../structure/HashMapEntry.html" title="class in structure">HashMapEntry</a>&nbsp;entry,
                <a href="../structure/FPeer.html" title="class in structure">FPeer</a>&nbsp;toAvoid)</pre>
<div class="block">Tries to find a candidate FPeer, scanning <code>neighborsList</code> from the beginning, that satisfies the following
 two tests: <br><br>
 
 test 1) it is not already present in the <code>sentTo</code> field of the passed HashMap <code>entry</code>; <br>
 test 2) it is different from the passed FPeer <code>toAvoid</code>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>neighborsList</code> - the list of neighbors to scan</dd><dd><code>entry</code> - the HashMap entry to check</dd><dd><code>toAvoid</code> - the FPeer to avoid</dd>
<dt><span class="strong">Returns:</span></dt><dd>a neighbors list's index in [0, size) if a candidate is found, >= size if it is not found.</dd></dl>
</li>
</ul>
<a name="changeAndSendMessage(structure.Message, structure.Message.Type, structure.FPeer, structure.FPeer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>changeAndSendMessage</h4>
<pre>private&nbsp;void&nbsp;changeAndSendMessage(<a href="../structure/Message.html" title="class in structure">Message</a>&nbsp;mex,
                        <a href="../structure/Message.Type.html" title="enum in structure">Message.Type</a>&nbsp;mexType,
                        <a href="../structure/FPeer.html" title="class in structure">FPeer</a>&nbsp;fpeer_sender,
                        <a href="../structure/FPeer.html" title="class in structure">FPeer</a>&nbsp;fpeer_receiver)</pre>
<div class="block">Utility method performing the following operations: <br>
 1) changes the type of the passed message <code>mex</code> exploiting the passed <code>mexType</code>; <br>
 2) changes the last-hop FPeer of the passed message <code>mex</code> exploiting the passed FPeer <code>fpeer_sender</code>; <br>
 3) sends the passed message <code>mex</code> from the passed FPeer <code>fpeer_sender</code> to the passed FPeer 
    <code>fpeer_receiver</code>. <br></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>mex</code> - the message to modify and to send</dd><dd><code>mexType</code> - the type to set as message type</dd><dd><code>fpeer_sender</code> - the reference to the FPeer to use as last-hop field and from which send the message</dd><dd><code>fpeer_receiver</code> - the reference to the FPeer to which send the message</dd></dl>
</li>
</ul>
<a name="storeContentAndInfo(structure.Message, structure.FPeer, structure.HashMapEntry)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>storeContentAndInfo</h4>
<pre>private&nbsp;void&nbsp;storeContentAndInfo(<a href="../structure/Message.html" title="class in structure">Message</a>&nbsp;m,
                       <a href="../structure/FPeer.html" title="class in structure">FPeer</a>&nbsp;fpeer,
                       <a href="../structure/HashMapEntry.html" title="class in structure">HashMapEntry</a>&nbsp;mEntry)</pre>
<div class="block">Stores the content location key of the passed message <code>m</code> into the local storage of the running FPeer <code>fpeer</code>,
 avoiding the store if the content location key is already present in the storage.
 Furthermore, stores the information triple (messageID, lastHopFPeer, null) into the running FPeer's HashMap, if the
 information does not already exists.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>m</code> - the message from which extract the informations</dd><dd><code>fpeer</code> - the FPeer in which store the message content location key</dd><dd><code>mEntry</code> - the HashMap entry relative to the message</dd></dl>
</li>
</ul>
<a name="sendMessage(peersim.core.Node, peersim.core.Node, structure.Message)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sendMessage</h4>
<pre>private&nbsp;void&nbsp;sendMessage(peersim.core.Node&nbsp;sender,
               peersim.core.Node&nbsp;receiver,
               <a href="../structure/Message.html" title="class in structure">Message</a>&nbsp;msg)</pre>
<div class="block">Sends the message <code>msg</code> from the FPeer <code>sender</code> to Hybrid protocol of the FPeer <code>receiver</code>.
 Furthermore, if the message is a GET or a PUT request, the method increases its THC value.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sender</code> - the node that send the message</dd><dd><code>receiver</code> - the node to which send the message</dd><dd><code>msg</code> - the message to send</dd></dl>
</li>
</ul>
<a name="replicatesTowardNeighbors(structure.FPeer, double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>replicatesTowardNeighbors</h4>
<pre>private&nbsp;void&nbsp;replicatesTowardNeighbors(<a href="../structure/FPeer.html" title="class in structure">FPeer</a>&nbsp;fpeer,
                             double&nbsp;contentLocKey)</pre>
<div class="block">Replicates the passed content location key <code>contentLocKey</code> sending at most <code>replicationFactor</code> PUT_REPLICATION
 messages from the running FPeer <code>fpeer</code> toward its top-neighbors, having all the same message identifier and
 the HTL value set to the <code>maxHTLvalue</code>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>fpeer</code> - the running FPeer that will perform the replication process</dd><dd><code>contentLocKey</code> - the content location key to replicate in the overlay network</dd></dl>
</li>
</ul>
<a name="handleMessageForwarding(structure.Message, structure.HashMapEntry, structure.FPeer, structure.FPeer, structure.FPeer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>handleMessageForwarding</h4>
<pre>private&nbsp;void&nbsp;handleMessageForwarding(<a href="../structure/Message.html" title="class in structure">Message</a>&nbsp;m,
                           <a href="../structure/HashMapEntry.html" title="class in structure">HashMapEntry</a>&nbsp;mEntry,
                           <a href="../structure/FPeer.html" title="class in structure">FPeer</a>&nbsp;fpeer_sender,
                           <a href="../structure/FPeer.html" title="class in structure">FPeer</a>&nbsp;fpeer_receveiver,
                           <a href="../structure/FPeer.html" title="class in structure">FPeer</a>&nbsp;fpeer_recFrom)</pre>
<div class="block">Utility method that handles the forwarding of the passed message <code>m</code>, performing the following operations: <br>
 
 1) decreases the <code>m</code>'s HTL field value; <br>
 2) changes the <code>m</code>'s last hop FPeer field with the passed <code>fpeer_sender</code>; <br>
 3) forwards the message <code>m</code> from <code>fpeer_sender</code> to the FPeer <code>fpeer_receiver</code>; <br>
 4) adds "received from <code>fpeer_recFrom</code>" and "sent to <code>fpeer_receiver</code>" informations into the 
          running FPeer's HashMap.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>m</code> - the message to forward</dd><dd><code>mEntry</code> - the HashMap entry relative to the message to send (possibly <code>null</code>)</dd><dd><code>fpeer_sender</code> - the FPeer from which forward the message</dd><dd><code>fpeer_receveiver</code> - the FPeer toward which forward the message</dd><dd><code>fpeer_recFrom</code> - the FPeer from which the running FPeer has received the message to forward</dd></dl>
</li>
</ul>
<a name="handleBackwardMessage(structure.FPeer, structure.Message)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>handleBackwardMessage</h4>
<pre>private&nbsp;void&nbsp;handleBackwardMessage(<a href="../structure/FPeer.html" title="class in structure">FPeer</a>&nbsp;fpeer,
                         <a href="../structure/Message.html" title="class in structure">Message</a>&nbsp;mex)</pre>
<div class="block">Handles the <code>fpeer</code>'s receiving of the backward message <code>mex</code> (e.g. PUT_OK, PUT_COLLISION, GET_FOUND),
 performing the following operations: <br>
 
 1) it checks its own HashMap to find the FPeer from which have received the relative FORWARD message (e.g. PUT, GET); <br>
 2) if that FPeer is ITSELF, this means that it is the owner of the FORWARD message, so do nothing and routing ends; 
    otherwise, it propagates the relative BACKWARD message (e.g. PUT_OK, PUT_COLLISION, GET_FOUND)  message toward that neighbor.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>fpeer</code> - the FPeer that have received the backward message</dd><dd><code>mex</code> - the received backward message</dd></dl>
</li>
</ul>
<a name="handleReceivedGET(structure.FPeer, structure.Message)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>handleReceivedGET</h4>
<pre>private&nbsp;void&nbsp;handleReceivedGET(<a href="../structure/FPeer.html" title="class in structure">FPeer</a>&nbsp;fpeer,
                     <a href="../structure/Message.html" title="class in structure">Message</a>&nbsp;mex)</pre>
<div class="block">Handles the <code>fpeer</code>'s receiving of the GET/GET_NOTFOUND message <code>mex</code>, performing the following operations: <br><br>
 
 First of all, it checks if its location key is the closest, w.r.t. the content location key, than all the location
 keys encountered up to now during the <code>mex</code>'s routing. If that key is the closest, then it changes the <code>mex</code>'s
 relative field with that key (see "CHECK 0"). <br><br>
 
 After, if <code>fpeer</code> contains the content location key in its own storage, it sends backward a GET_FOUND message to the 
 neighbor from which it has received the GET/GET_NOTFOUND message <code>mex</code> (see "CHECK 1"); <br><br>
   
 Otherwise, if  has already received the same (check on unique ID) GET message <code>mex</code>, it send backward
 a GET_NOTFOUND message to the neighbor from which it has received the GET message <code>mex</code> (see "CHECK 2"); <br><br>
 
 Otherwise, <code>mex</code> is not a duplicated GET and <code>fpeer</code> does NOT contains the requested content location key.
 At this point, if <code>fpeer</code> is the closest in the routing path, it resets HTL to the maximum value (see "CHECK 3"). 
 After that, <code>fpeer</code> checks the HTL value: <br><br>
 
        - if HTL = 0, then <code>fpeer</code> backwards a GET_NOTFOUND message to the neighbor from which it has received 
          the GET message <code>mex</code> (obviously, if it is not the owner); (see "CHECK 4") <br>
 
        - if HTL > 0, then <code>fpeer</code> searches for an its candidate neighbor having the following characteristics: <br><br>
   
                1) it is the <code>fpeer</code>'s neighbor closest w.r.t. the content location key; <br>
                2) it is not already visited during the current Bounded-Depth-First Search;  <br>
                3) it is different from the FPeer from which <code>fpeer</code> has received the GET message. <br><br>

        If such neighbor does NOT exists, <code>fpeer</code> backwards a GET_NOTFOUND message to the neighbor from which it has 
        received the GET message <code>mex</code>; <br><br>
          
        If such neighbor exists, then <code>fpeer</code> forwards the received GET message <code>mex</code> to this candidate neighbor, 
        decreasing its HTL value.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>fpeer</code> - the FPeer that have received the message (e.g. GET, GET_NOTFOUND)</dd><dd><code>mex</code> - the received message (e.g. GET, GET_NOTFOUND)</dd></dl>
</li>
</ul>
<a name="handleReceivedPUT(structure.FPeer, structure.Message)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>handleReceivedPUT</h4>
<pre>private&nbsp;void&nbsp;handleReceivedPUT(<a href="../structure/FPeer.html" title="class in structure">FPeer</a>&nbsp;fpeer,
                     <a href="../structure/Message.html" title="class in structure">Message</a>&nbsp;mex)</pre>
<div class="block">Handles the <code>fpeer</code>'s receiving of the PUT message <code>mex</code>, performing the following operations: <br><br>
 
 - if <code>fpeer</code> contains the content location key in its own storage, it send backward a PUT_COLLISION message to the 
   neighbor from which it has received the PUT message <code>mex</code>; <br>
 
 - otherwise, <code>fpeer</code> try to select a neighbor that is closest w.r.t. the content location key to PUT than its
   location key: <br><br>
   
        => if this neighbor exists, <code>fpeer</code> forward the PUT request toward it; <br>
        => if this neighbor does not exists, <code>fpeer</code> stores the content location key in its own storage and forwards
           a PUT_REPLICATION message toward the <code>replicationFactor</code> closest w.r.t. the content location key neighbors, 
           having maximum HTL value and its reference as last hop FPeer.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>fpeer</code> - the FPeer that have received the PUT message</dd><dd><code>mex</code> - the received PUT message</dd></dl>
</li>
</ul>
<a name="handleReceivedPUT_REPLICATION(structure.FPeer, structure.Message)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>handleReceivedPUT_REPLICATION</h4>
<pre>private&nbsp;void&nbsp;handleReceivedPUT_REPLICATION(<a href="../structure/FPeer.html" title="class in structure">FPeer</a>&nbsp;fpeer,
                                 <a href="../structure/Message.html" title="class in structure">Message</a>&nbsp;mex)</pre>
<div class="block">Handles the <code>fpeer</code>'s receiving of the PUT_REPLICATION/PUT_REPL_COLLISION message <code>mex</code>, performing the 
 following operations: <br><br>
 
 First of all, it checks if its location key is the closest, w.r.t. the content location key, than all the location
 keys encountered up to now during the <code>mex</code>'s routing. If that key is the closest, then it changes the 
 <code>mex</code>'s relative field with that key (see "CHECK 0"). <br><br>
   
 After, if <code>fpeer</code> has already received the same (check on unique ID) PUT_REPLICATION message <code>mex</code>, it 
 sends backward a PUT_REPL_COLLISION message to the neighbor from which it has received the PUT_REPLICATION message 
 <code>mex</code> (see "CHECK 1"); <br><br>
 
 Otherwise, if <code>fpeer</code> is the closest in the routing path, it resets HTL to the maximum value (see "CHECK 2"). 
 After that, <code>fpeer</code> checks the HTL value: <br><br>
 
        - if HTL = 0, then <code>fpeer</code> stores the content location key to replicate in its own storage (see "CHECK 3") <br>
 
        - if HTL > 0, then <code>fpeer</code> searches for an its candidate neighbor having the following characteristics: <br><br>
   
                1) it is the <code>fpeer</code>'s neighbor closest w.r.t. the content location key; <br>
                2) it is not already visited during the current Bounded-Depth-First Search;  <br>
                3) it is different from the FPeer from which <code>fpeer</code> has received the GET message. <br><br>

        If such neighbor does NOT exists, <code>fpeer</code> stores the content location key to replicate in its own storage ; <br><br>
          
        If such neighbor exists and it is closest w.r.t. the content location key than <code>fpeer</code>, then it forwards the 
  PUT_REPLICATION message to this candidate neighbor, decreasing the message's HTL value.
  Otherwise, it stores the content location key to replicate in its own storage.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>fpeer</code> - the FPeer that have received the message (e.g. PUT_REPLICATION, PUT_REPL_COLLISION)</dd><dd><code>mex</code> - the received message (e.g. PUT_REPLICATION, PUT_REPL_COLLISION)</dd></dl>
</li>
</ul>
<a name="selectNeighborForSwap(structure.FPeer, protocol.LinkableProtocol)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>selectNeighborForSwap</h4>
<pre>private&nbsp;<a href="../structure/FPeer.html" title="class in structure">FPeer</a>&nbsp;selectNeighborForSwap(<a href="../structure/FPeer.html" title="class in structure">FPeer</a>&nbsp;fpeer_proposer,
                          <a href="../protocol/LinkableProtocol.html" title="class in protocol">LinkableProtocol</a>&nbsp;lp)</pre>
<div class="block">Tries to select a neighbor of the passed FPeer <code>fpeer_proposer</code> to involves into a SWAP process with itself.
 The choice is made taking care that a neighbor is not already involved in a SWAP process with another FPeer and that
 the selecting process ends also if no FPeers are available, after some attempts.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>fpeer_proposer</code> - the running FPeer that tries to select an its neighbor</dd><dd><code>lp</code> - the Linkable protocol of the running FPeer</dd>
<dt><span class="strong">Returns:</span></dt><dd><code>null</code> if the running FPeer is involved itself in a SWAP process or there are no neighbors available for
                   the SWAP. <code>fpeer_candidate</code>, the reference to the selected FPeer, if it is availbale for the SWAP.</dd></dl>
</li>
</ul>
<a name="handleReceivedSWAP(structure.FPeer, structure.Message)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>handleReceivedSWAP</h4>
<pre>private&nbsp;void&nbsp;handleReceivedSWAP(<a href="../structure/FPeer.html" title="class in structure">FPeer</a>&nbsp;fpeer,
                      <a href="../structure/Message.html" title="class in structure">Message</a>&nbsp;mex)</pre>
<div class="block">Handles the <code>fpeer</code>'s receiving of the SWAP message <code>mex</code> performing the following operations: <br><br>
 
 First of all, it checks the HTL value of the message: if HTL > 0, then it select a random neighbor (different from 
 this from which it has received the actual request) toward which forward the SWAP request. 
 Otherwise, if HTL = 0, it performs the following actions: <br><br>
 
 1) computes the product of the distances between the SWAP request-owner FPeer's location key and the location keys of each one 
    of its neighbors (see "prodAA"); <br>
 
 2) computes the product of the distances between <code>fpeer</code>'s location key and the location keys of each one of the
    SWAP request-owner FPeer's neighbors (see "prodBA"); <br>
 
 3) computes the product of the distances between the <code>fpeer</code>'s location key and the location keys of each one of its
          neighbors (see "prodBB"); <br>
 
 4) computes the product of the distances between the SWAP request-owner FPeer's location key and the location keys of each one
          of <code>fpeer</code>'s neighbors (see "prodAB"); <br><br>
     
 After, it computes the product between the distances before and after (the eventual) swap of the two involved FPeers (see "D1" and "D2"). 
 
 The next backward operation depends on the values of "D1" and "D2": <br><br>
 
                - if D1 >  D2, then <code>fpeer</code> send a SWAP_OK message to the FPeer owner of the SWAP request (swap request approved); <br>
                - if D2 <= D1, then <code>fpeer</code> send a SWAP_OK message with probability D1 / D2 (see "D_AB"), while a 
                  SWAP_REFUSED otherwise (swap request refused).</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>fpeer</code> - the FPeer that have received the SWAP message</dd><dd><code>mex</code> - the received SWAP message</dd></dl>
</li>
</ul>
<a name="handleReceivedSWAPanswer(structure.FPeer, structure.Message)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>handleReceivedSWAPanswer</h4>
<pre>private&nbsp;void&nbsp;handleReceivedSWAPanswer(<a href="../structure/FPeer.html" title="class in structure">FPeer</a>&nbsp;fpeer,
                            <a href="../structure/Message.html" title="class in structure">Message</a>&nbsp;mex)</pre>
<div class="block">Handles the <code>fpeer</code>'s receiving of the answer <code>mex</code> relative to the SWAP message (e.g. SWAP_OK, SWAP_REFUSED)  
 sent in the past, performing the following operations: <br><br>
 
 - if the received message is of type SWAP_REFUSED, do nothing; <br>
 
 - otherwise, if the received message is of type SWAP_OK, <code>fpeer</code> swaps its location key and its stored content location 
         keys with the location key and the stored content location keys of the FPeer from which it has received the answer. <br><br>
 
 In both the cases, it sets the status of the two SWAP-involved FPeers in "not involved into a SWAP process".</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>fpeer</code> - the FPeer that have received the answer message</dd><dd><code>mex</code> - the received answer message (e.g. SWAP_OK, SWAP_REFUSED)</dd></dl>
</li>
</ul>
<a name="processEvent(peersim.core.Node, int, java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>processEvent</h4>
<pre>public&nbsp;void&nbsp;processEvent(peersim.core.Node&nbsp;peer,
                int&nbsp;pid,
                java.lang.Object&nbsp;message)</pre>
<div class="block">Handles the receiving of a message <code>message</code> from an FPeer <code>peer</code>, using the protocol having <code>pid</code>.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code>processEvent</code>&nbsp;in interface&nbsp;<code>peersim.edsim.EDProtocol</code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>peer</code> - the FPeer that have received the message</dd><dd><code>pid</code> - the identifier of the protocol that have sent the message</dd><dd><code>message</code> - the received message of type as specified in enum <code>Message.Type</code></dd></dl>
</li>
</ul>
<a name="performRequest(structure.Message.Type, structure.FPeer, double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>performRequest</h4>
<pre>public&nbsp;void&nbsp;performRequest(<a href="../structure/Message.Type.html" title="enum in structure">Message.Type</a>&nbsp;mexType,
                  <a href="../structure/FPeer.html" title="class in structure">FPeer</a>&nbsp;fpeer_sender,
                  double&nbsp;contentLocKey)</pre>
<div class="block">Implements the GET, PUT and SWAP requests operations, based on the passed parameter <code>mexType</code>: <br><br>
  
  - for <code>mexType</code> = PUT, <code>fpeer_sender</code> injects the passed content location key <code>contentLocKey</code> into the overlay network, 
    sending a PUT message request. The message is sent to the neighbor that have location key closest w.r.t. the content location key 
    <code>contentLocKey</code> to put. <br>
  
  - for <code>mexType</code> = GET, <code>fpeer_sender</code> search the passed content location key <code>contentLocKey</code> into the overlay network, 
    sending a GET message request. The message is sent to the neighbor that have location key closest w.r.t. the content location key 
    <code>contentLocKey</code> to get. <br>
    
        - for <code>mexType</code> = SWAP, <code>fpeer_sender</code> select randomly an its neighbor and send to it the SWAP message request. <br><br>
     
  In the GET and PUT cases, <code>fpeer_sender</code> stores in its own HashMap an entry with the following informations: <br><br>
  
        1) "request received from itself", storing the <code>fpeer_sender</code>'s reference in the field "receivedFrom"; <br>
        2) "request sent to selectedNeighbor", storing selected neighbors's reference in the HashSet-field "sentTo"; <br><br>
     
  Only in the case of the PUT, obviously, the request is not sent if <code>fpeer_sender</code> already contains the content location
  key <code>contentLocKey</code> or if it is the closest, w.r.t. the content location key in the neighborhood.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>mexType</code> - the type of the request to perform (e.g. GET, PUT or SWAP)</dd><dd><code>fpeer_sender</code> - the FPeer that performs the request into the overlay</dd><dd><code>contentLocKey</code> - the content location key to GET from or PUT into the overlay network (unused for SWAP request)</dd></dl>
</li>
</ul>
<a name="nextCycle(peersim.core.Node, int)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>nextCycle</h4>
<pre>public&nbsp;void&nbsp;nextCycle(peersim.core.Node&nbsp;peer,
             int&nbsp;pid)</pre>
<div class="block">Implements the running FPeer's performing of some requests, based on probability and periods criteria.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code>nextCycle</code>&nbsp;in interface&nbsp;<code>peersim.cdsim.CDProtocol</code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>peer</code> - the overlay network's FPeer associated to the protocol that performs the cycle</dd><dd><code>pid</code> - the protocol identifier of the running protocol</dd></dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/MessagesExchangerProtocol.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../deprecated-list.html">Deprecated</a></li>
<li><a href="../index-files/index-1.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../protocol/LinkableProtocol.html" title="class in protocol"><span class="strong">Prev Class</span></a></li>
<li>Next Class</li>
</ul>
<ul class="navList">
<li><a href="../index.html?protocol/MessagesExchangerProtocol.html" target="_top">Frames</a></li>
<li><a href="MessagesExchangerProtocol.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
